<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <style media="screen">
    body{
      overflow:hidden;
    }
  </style>
  <body>
    <p id="testAlert"></p>
    <img hidden id="tilesetPlayers" src="https://raw.githubusercontent.com/mooodev/goblintown/main/images/01%20-%20Full%20spritesheet%20(16x24).png" alt="">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  

      <script type="text/javascript">
        console.log("Hello world")




        var keyState = [];

        window.addEventListener("keydown", function(e) {
        keyState[e.keyCode] = true;
        });
        window.addEventListener("keyup", function(e) {
        keyState[e.keyCode] = false;
        });








        //texture animator duh
        function TextureAnimator(texture, tilesHoriz, tilesVert, fromTile, numTiles, tileDispDuration) {
        			this.tilesHorizontal = tilesHoriz;
        			this.tilesVertical = tilesVert;
        			// how many images does this spritesheet contain?
        			this.numberOfTiles = numTiles;
        			texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        			texture.repeat.set(1 / this.tilesHorizontal, 1 / this.tilesVertical);
        			// how long should each image be displayed?
        			this.tileDisplayDuration = tileDispDuration;
        			// how long has the current image been displayed?
        			this.currentDisplayTime = 0;
        			// which image is currently being displayed?
        			this.currentTile = 0;
        			this.update = function(milliSec, tileRow) {
        				this.currentDisplayTime += milliSec;
        				while (this.currentDisplayTime > this.tileDisplayDuration) {
        					this.currentDisplayTime -= this.tileDisplayDuration;
        					this.currentTile++;
        					if (this.currentTile == this.numberOfTiles)
        						this.currentTile = 0;
        					var currentColumn = this.currentTile % this.tilesHorizontal;
        					texture.offset.x = (currentColumn) / this.tilesHorizontal;
        					var currentRow = Math.floor(this.currentTile / this.tilesHorizontal) + tileRow;
        					texture.offset.y = currentRow / this.tilesVertical;
        					}
        				};
        			};


              //THREE JS && 3d stuff
              const scene = new THREE.Scene();
              const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
              const renderer = new THREE.WebGLRenderer({  });
              renderer.setSize( window.innerWidth, window.innerHeight );
              document.body.appendChild( renderer.domElement );
              camera.position.z = 10;
              // camera.position.x = 8;
              // camera.position.y = 8;

              // var tileImg = document.createElement("IMG");
              // var tileCanvas = document.createElement("CANVAS")
              // tileCanvas.width = 32;
              // tileCanvas.height = 32;
              // tileImg.src = _FarmbgString;
              // var tileCanvasctx = tileCanvas.getContext("2d");
              //
              // var _prepareBgTexture = () => {
              //   tileCanvas.width = 32;
              //   tileCanvas.height = 32;
              //   tileCanvasctx.clearRect(0, 0, 32, 32);
              //   tileCanvasctx.drawImage(tileImg, 160, 0, 32, 32, 0, 0, 32, 32);
              // }
              //
              //
              //
              //
              // class Player{
              //
              // }
              // class PlayerAnimation{
              //   this.sprite;
              //   this.speed;
              //   this.tileDimensions;
              // }
              //
              //
              //
              let playerTexture = document.getElementById("tilesetPlayers")
              let _texPlayers = new THREE.TextureLoader().load(playerTexture);
              //  let testannie = new TextureAnimator(_texP, 4, 4, 2, 3, 175);
               const geometryP = new THREE.PlaneGeometry(1, 1.5);
               const materialP = new THREE.MeshBasicMaterial({
                   // map: _texP,
                   // transparent: true
               });
               let player = new THREE.Mesh(geometryP, materialP);
               //player.material.map.needsUpdate = true;
               scene.add(player);
               player.position.x = 0;
               player.position.y = 0;
               player.position.z = 0.05;


        document.addEventListener('touchstart', handleTouchStart, false);        
document.addEventListener('touchmove', handleTouchMove, false);

var xDown = null;                                                        
var yDown = null;

function getTouches(evt) {
  return evt.touches ||             // browser API
         evt.originalEvent.touches; // jQuery
}                                                     
                                                                         
function handleTouchStart(evt) {
    const firstTouch = getTouches(evt)[0];                                      
    xDown = firstTouch.clientX;                                      
    yDown = firstTouch.clientY;                                      
};                                                
                                                                         
function handleTouchMove(evt) {
    if ( ! xDown || ! yDown ) {
        return;
    }

    var xUp = evt.touches[0].clientX;                                    
    var yUp = evt.touches[0].clientY;

    var xDiff = xDown - xUp;
    var yDiff = yDown - yUp;
                                                                         
    if ( Math.abs( xDiff ) > Math.abs( yDiff ) ) {/*most significant*/
        if ( xDiff > 0 ) {
           document.getElementById("testAlert").innerText = "RIGHT"
        } else {
            /* left swipe */
          document.getElementById("testAlert").innerText = "LEFT"
        }                       
    } else {
        if ( yDiff > 0 ) {
            /* down swipe */ 
          document.getElementById("testAlert").innerText = "DOWT"
        } else { 
            /* up swipe */
          document.getElementById("testAlert").innerText = "UPZ"
        }                                                                 
    }
    /* reset values */
    xDown = null;
    yDown = null;                                             
};


              var clock = new THREE.Clock();
              const animate = function () {
                var delta = clock.getDelta();

                requestAnimationFrame( animate );
                renderer.render( scene, camera );
              };
              animate();
        window.scrollTo(0,0)

      </script>
  </body>
</html>
