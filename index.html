<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <style media="screen">
    body{
      overflow:hidden;
    }
  </style>
  <body>
    <!-- <img hidden id="tilesetPlayers" src="https://raw.githubusercontent.com/mooodev/goblintown/main/images/01%20-%20Full%20spritesheet%20(16x24).png" alt=""> -->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://telegram.org/js/telegram-web-app.js"></script>

      <script type="text/javascript">
        console.log("Hello world")
let tg = window.Telegram.WebApp;





        var keyState = [];

        window.addEventListener("keydown", function(e) {
        keyState[e.keyCode] = true;
        });
        window.addEventListener("keyup", function(e) {
        keyState[e.keyCode] = false;
        });








        //texture animator duh
        function TextureAnimator(texture, tilesHoriz, tilesVert, fromTile, numTiles, tileDispDuration) {
        			this.tilesHorizontal = tilesHoriz;
        			this.tilesVertical = tilesVert;
        			// how many images does this spritesheet contain?
        			this.numberOfTiles = numTiles;
        			texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        			texture.repeat.set(1 / this.tilesHorizontal, 1 / this.tilesVertical);
        			// how long should each image be displayed?
        			this.tileDisplayDuration = tileDispDuration;
        			// how long has the current image been displayed?
        			this.currentDisplayTime = 0;
        			// which image is currently being displayed?
        			this.currentTile = 0;
        			this.update = function(milliSec, tileRow) {
        				this.currentDisplayTime += milliSec;
        				while (this.currentDisplayTime > this.tileDisplayDuration) {
        					this.currentDisplayTime -= this.tileDisplayDuration;
        					this.currentTile++;
        					if (this.currentTile == this.numberOfTiles)
        						this.currentTile = 0;
        					var currentColumn = this.currentTile % this.tilesHorizontal;
        					texture.offset.x = (currentColumn) / this.tilesHorizontal;
        					var currentRow = Math.floor(this.currentTile / this.tilesHorizontal) + tileRow;
        					texture.offset.y = currentRow / this.tilesVertical;
        					}
        				};
        			};


              //THREE JS && 3d stuff
              const scene = new THREE.Scene();
              const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
              const renderer = new THREE.WebGLRenderer({  });
              renderer.setSize( window.innerWidth, window.innerHeight );
              document.body.appendChild( renderer.domElement );
              camera.position.z = 10;
              // camera.position.x = 8;
              // camera.position.y = 8;

              // var tileImg = document.createElement("IMG");
              // var tileCanvas = document.createElement("CANVAS")
              // tileCanvas.width = 32;
              // tileCanvas.height = 32;
              // tileImg.src = _FarmbgString;
              // var tileCanvasctx = tileCanvas.getContext("2d");
              //
              // var _prepareBgTexture = () => {
              //   tileCanvas.width = 32;
              //   tileCanvas.height = 32;
              //   tileCanvasctx.clearRect(0, 0, 32, 32);
              //   tileCanvasctx.drawImage(tileImg, 160, 0, 32, 32, 0, 0, 32, 32);
              // }
              //
              //
              //
              //
              // class Player{
              //
              // }
              // class PlayerAnimation{
              //   this.sprite;
              //   this.speed;
              //   this.tileDimensions;
              // }
              //
              //
              //
            //  let playerTexture = document.getElementById("tilesetPlayers")
            //  let _texPlayers = new THREE.TextureLoader().load(playerTexture);
              //  let testannie = new TextureAnimator(_texP, 4, 4, 2, 3, 175);
               const geometryP = new THREE.PlaneGeometry(1, 1.5);
               const materialP = new THREE.MeshBasicMaterial({
                   // map: _texP,
                   // transparent: true
               });
               let player = new THREE.Mesh(geometryP, materialP);
               //player.material.map.needsUpdate = true;
               scene.add(player);
               player.position.x = 0;
               player.position.y = 0;
               player.position.z = 0.05;




              var clock = new THREE.Clock();
              const animate = function () {
                var delta = clock.getDelta();

                requestAnimationFrame( animate );
                renderer.render( scene, camera );
              };
              animate();







//               document.addEventListener('touchstart', handleTouchStart, false);
// document.addEventListener('touchmove', handleTouchMove, false);
//
// var xDown = null;
// var yDown = null;
//
// function getTouches(evt) {
//   return evt.touches ||             // browser API
//          evt.originalEvent.touches; // jQuery
// }
//
// function handleTouchStart(evt) {
//     const firstTouch = getTouches(evt)[0];
//     xDown = firstTouch.clientX;
//     yDown = firstTouch.clientY;
// };
//
// function handleTouchMove(evt) {
//     if ( ! xDown || ! yDown ) {
//         return;
//     }
//
//     var xUp = evt.touches[0].clientX;
//     var yUp = evt.touches[0].clientY;
//
//     var xDiff = xDown - xUp;
//     var yDiff = yDown - yUp;
//
//     if ( Math.abs( xDiff ) > Math.abs( yDiff ) ) {/*most significant*/
//         if ( xDiff > 0 ) {
//             /* right swipe */
//         } else {
//             /* left swipe */
//         }
//     } else {
//         if ( yDiff > 0 ) {
//             /* down swipe */
//         } else {
//             /* up swipe */
//         }
//     }
//     /* reset values */
//     xDown = null;
//     yDown = null;
// };


//g.initData //получаем данные от пользователя в виде строки (работает только при запуске из меню команд бота).
//tg.initDataUnsafe // получаем данные от пользователя в виде объекта (работает только при запуске из меню команд бота).
 // возвращает true, если приложение открыто на всю высоту, false - если нет.
console.log(tg.viewportHeight) // вернёт ширину окна.
//tg.sendData("Hello") // отправляет данные  боту в строковом виде, после чего закрывает приложение (работает только если приложение запущено с keyboard button).


window.addEventListener('load', (event) => {
  console.log('page is fully loaded');
  console.log(tg.ready(),tg.isExpanded) // метод позволяет отследить, когда приложение готово к отображению.
  tg.expand()
//  tg.expand()// метод позволяет растянуть окно на всю высоту.
});

// tg.close() // метод закрывает приложение.

tg.MainButton.text = 'Attack!' // текст кнопки, по умолчанию: "Continue"
// tg.MainButton.color // цвет текста
// tg.MainButton.textColor // цвет подложки
// tg.MainButton.isVisible // видна ли кнопка (по умолчанию false)
tg.MainButton.isActive // активна ли кнопка (по умолчанию true)

tg.MainButton.onClick(testingMainButton()) // метод при нажатии на кнопку
tg.MainButton.enable() // сделать активной
tg.MainButton.show() // показать кнопку
// tg.MainButton.hide() // скрыть кнопку

// tg.MainButton.disable() // сделать неактивной
// tg.MainButton.setParams(params) // задает параметры в виде объекта

var testingMainButton = () => {
  console.log("Oh yeahhh")
  tg.MainButton.setText("Danger is near..") //  метод для задания текста
}

      </script>
  </body>
</html>
