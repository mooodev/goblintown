<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title></title>
    <style media="screen">
      body{
        font-size: 4vw;
        color:#008106;
        background-color:#1f1f1f;
      }
      .mainHolder{
        overflow:scroll;
      }
    </style>
  </head>
  <body>
    <button type="button" onclick="testingMainButton()" name="button">test</button>

      <h1 id="mainHeaderPanel">Miner 0.0.1</h1>
      <div class="mainHolder">
      <p id="mainInfoPanel">c:/_</p>
    </div>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.0.0/crypto-js.min.js"></script>

    <script type="text/javascript">
      console.log("Hello world")
let tg = window.Telegram.WebApp;




//g.initData //получаем данные от пользователя в виде строки (работает только при запуске из меню команд бота).
//tg.initDataUnsafe // получаем данные от пользователя в виде объекта (работает только при запуске из меню команд бота).
 // возвращает true, если приложение открыто на всю высоту, false - если нет.
console.log(tg.viewportHeight) // вернёт ширину окна.
//tg.sendData("Hello") // отправляет данные  боту в строковом виде, после чего закрывает приложение (работает только если приложение запущено с keyboard button).


window.addEventListener('load', (event) => {
  console.log('page is fully loaded');
  _isClickPossible = true;
  tg.expand()
  // tg.close() // метод закрывает приложение.

  tg.MainButton.text = 'Its Hack-time!' // текст кнопки, по умолчанию: "Continue"
  // tg.MainButton.color // цвет текста
  // tg.MainButton.textColor // цвет подложки
  // tg.MainButton.isVisible // видна ли кнопка (по умолчанию false)
  tg.MainButton.isActive // активна ли кнопка (по умолчанию true)

  tg.MainButton.onClick(testingMainButton) // метод при нажатии на кнопку
  tg.MainButton.enable() // сделать активной
  tg.MainButton.show() // показать кнопку
  // tg.MainButton.hide() // скрыть кнопку

  // tg.MainButton.disable() // сделать неактивной
  // tg.MainButton.setParams(params) // задает параметры в виде объекта

//  tg.expand()// метод позволяет растянуть окно на всю высоту.
});



class Miner{
  constructor(){
    this.speed = 1000;
    //startup miner
    this.timer = 1000;
    this.powered = false;
    this.nonce = 0;
    this.currentString = '';
    this.userId = 'user';
  }
  powerOn(){
    this.powered = true;
    tg.MainButton.setText("Mining...")
    chatboxModule.addTypewriter(document.getElementById("mainHeaderPanel"), "///Mining in action!", 10)
    this.nonce = 0;
  }
  powerOff(){
    this.powered = false;
    tg.MainButton.setText("Start")
    chatboxModule.addTypewriter(document.getElementById("mainHeaderPanel"), "///standby mode...", 10)
  }
  mineLoop(delta){
    if(this.powered){
      this.timer -= delta;
      if(this.timer < 0){
        this.timer = this.speed;
        this.hashingProcess()
      }
    }
  }
  hashingProcess(){
    this.currentString = world.currentSituation.toString()
    let _nonceString = this.currentString + this.nonce + this.userId.toString();
    this.nonce++;
    let hash;
    hash = CryptoJS.SHA256(_nonceString.toString());
    hash = hash.toString(CryptoJS.enc.Hex)
    addNewTypeInfoParagraph(hash)
    if(world.checkForReward(hash)){
      //mined a block event!
      addNewTypeInfoParagraph("REWARD RECIVED ---->")
      this.powerOff()
    }
  }
}


class World{
  constructor(){
    this.difficulty = 1;
    this.currentSituation = Math.random()
  }
  checkForReward(hash){
let difficultyJackpot = 0;
for(let n = 0; n < this.difficulty ; n++){
  if(Number(hash.charAt(n)) == n){
    difficultyJackpot++;
  }
}
    if(difficultyJackpot == this.difficulty){
      //solved! Recive reward please
      this.currentSituation = Math.random()
      return true;
    }else{
      return false;
    }
  }
}


let addNewTypeInfoParagraph = (text) => {
  let newElement = document.createElement("p");
  document.getElementById("mainInfoPanel").prepend(newElement)
  chatboxModule.addTypewriter(newElement,text, 15)
}


const world = new World();
const myNewMiner = new Miner();
myNewMiner.speed = 2500;



var testingMainButton = () => {
  if(!myNewMiner.powered){
    myNewMiner.powerOn();
  }else{
    console.log("not yet ready")
  }
}





class TypewritersMax {
    constructor() {
        this.typewritersArray = [];
        this.targetsArray = [];
    }
    addTypewriter(target, text, speed) {
      target.innerText = '';
      if(target.style.opacity == '' || target.style.opacity == '0'){
        target.style.opacity =  1;
      }
        let newtypewriter = new CommonTypewriter(speed, text)
        this.targetsArray.push(target);
        this.typewritersArray.push(newtypewriter);
        return true;
    }
    deleteTypewriter(target) {
      this.targetsArray.splice(target, 1);
      this.typewritersArray.splice(target, 1);
      return true;
    }
    executeTypingAcrossAllArrays(delta){
        if (this.targetsArray.length == 0) return;
        for (let t = 0; t < this.typewritersArray.length; t++) {
            let talkbox = this.typewritersArray[t]
            if (talkbox.type(delta)) {
                this.targetsArray[t].innerText = talkbox.currentText;
                if (talkbox.dead) {
                  this.deleteTypewriter(t)
                }
            }
        }
        return true;
    }
}

class CommonTypewriter {
    constructor(speed, final) {
        this.currentText = '';
        this.finalText = final;
        this.currentTimer = 200;
        this.speed = speed;
        this.dead = false;
    }
    addNextLetter() {
        //and check if writing is done
        if (this.currentText == this.finalText) {
            //console.log("Writing is done!")
            this.dead = true;
        } else {
            //adding one letter
            this.currentText = this.finalText.slice(0, this.currentText.length + 1)
        }
    }
    type(delta) {
        this.currentTimer -= delta;
        if (this.currentTimer < 0) {
            this.currentTimer = this.speed;
            //typing next letter now
            this.addNextLetter()
            return true;
        } else {
            return false;
        }
    }
}


let _isClickPossible = false;
const chatboxModule = new TypewritersMax()
let _timer = new Date().getTime();
let animate = () => {
    _delta = new Date().getTime() - _timer;
    _timer = new Date().getTime();
    //console.log("delta equal " + _delta)
    //TYPEWRITERS AND CHATS
    chatboxModule.executeTypingAcrossAllArrays(_delta)
    myNewMiner.mineLoop(_delta)
    window.requestAnimationFrame(animate)
}
animate();


    </script>
  </body>
</html>
